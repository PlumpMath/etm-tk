#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys
import etmKv.data as data
from etmKv.data import get_current_time, init_localization, str2hsh, hsh2str

from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.textinput import TextInput
from kivy.uix.codeinput import CodeInput
from kivy.uix.button import Button
# from kivy.uix.widget import Widget

from pygments.lexers.special import TextLexer

from kivy.uix.modalview import ModalView
from kivy.properties import ObjectProperty
from kivy.config import Config
from kivy.clock import Clock
Config.set('graphics', 'height', '420')
Config.set('graphics', 'width', '520')

import gettext
_ = gettext.gettext


class ETMEditor(CodeInput):

    def __init__(self, parent=None, callback=None):
        self.parent = parent
        self.button = Button
        self.callback = callback
        super(ETMEditor, self).__init__(multiline=True, size_hint=(1, None), height=300, lexer=TextLexer())
        self.modified = False
        self.bind(focus=self.on_focus)

    def _keyboard_on_key_up(self, window, keycode):
        # inform ETMDialog about the modification state
        if self.callback:
            self.callback((len(self._undo) > 0))
        super(ETMEditor, self)._keyboard_on_key_up(
            window, keycode)

    def on_focus(self, instance, value):
        if value:
            print('Editor focused', instance)
        else:
            print('Editor defocused', instance)
        super(ETMEditor, self).on_focus(instance, value)


class ETMDialog():

    def __init__(self, parent=None, options={}):
        self.parent = parent
        self.options = options
        self.editor = ETMEditor()
        self.text = ''

        self.btnchecksave = Button(text=_('Close'), size_hint_y=None, height='30sp')
        self.btncancel = Button(text=_('Cancel'), size_hint_y=None, height='30sp')
        buttons = BoxLayout(orientation='horizontal', height='30sp')
        buttons.add_widget(self.btncancel)
        buttons.add_widget(self.btnchecksave)
        self.message = TextInput(text="", size_hint_y=None, height=80)
        self.message.readonly = True
        self.message.background = [1, 1, 1, 1]
        self.content = BoxLayout(orientation='vertical')
        self.content.padding = 3
        self.content.spacing = 3

        self.input = ETMEditor(callback=self.set_modified)
        self.input.background_color = [1, 1, 1, 1]
        self.input.font_size = self.options['fontsize']

        self.content.add_widget(self.input)
        self.content.add_widget(self.message)
        self.content.add_widget(buttons)
        self.popup = ModalView(size_hint=(None, None), size=(500, 420))
        self.popup.add_widget(self.content)
        self.btnchecksave.bind(on_release=self.check_save)
        self.btncancel.bind(on_release=self.cancel)

    def run(self, text="", msg=""):
        print('run', text, msg)
        self.input.text = text
        self.message.text = msg
        self.input.reset_undo()
        self.input.focus = True
        print('opening popup')
        self.popup.open()

    def cancel(self, value):
        self.parent.mode = 'command'
        self.input.text = ''
        self.popup.dismiss()

    def check_save(self, value):
        new_str = ''
        if self.modified:
            print('check_save', self.input.text)
            new_hsh, msg = str2hsh(self.input.text, options=self.options)
            if msg:
                self.message.text = "\n".join(msg)
            else:
                try:
                    new_str = hsh2str(new_hsh, self.options)
                    # print('new_str', new_str, self.parent.mode)
                    new_item = unicode(u"{0}".format(hsh2str(new_hsh, self.options)))
                    self.input.text = new_item
                    if self.parent.mode == 'append':
                        self.parent.loop.append_item(new_hsh, new_item)
                    elif self.parent.mode == 'replace':
                        self.parent.loop.replace_item(new_hsh, new_item)
                    # self.message.text = self.parent.loop.do_n(arg_str=new_item)
                    self.set_modified(False)
                except:
                    self.message.text = "Error processing %s" % new_hsh
        else:  # close
            if new_str:
                self.parent.output_wid.text = new_str
            self.cancel(value)

    def set_modified(self, bool):
        # print('set_modified', bool)
        self.modified = bool
        if bool:
            self.btnchecksave.text = _('Save')
        else:
            self.btnchecksave.text = _('Close')


class ETMTextInput(TextInput):

    history = []
    index = 0
    now = None
    options = {}
    popup = ''
    value = ''
    firsttime = True
    mode = 'command'   # or edit or delete
    item_hsh = {}

    def _keyboard_on_key_down(self, window, keycode, text, modifiers):
        # print(keycode)
        if keycode[0] == 273:  # 273 is the keycode for up
            self.previous_history()
        elif keycode[0] == 274:  # 274 is the keycode for down
            self.next_history()
        elif keycode[0] == 13:  # 13 is the keycode for enter
            self.process_input()
        elif keycode[0] == 27:  # escape
            self.select_all()
            self.delete_selection()
            # return True to avoid closing app
            return(True)
        else:
            super(ETMTextInput, self)._keyboard_on_key_down(
                window, keycode, text, modifiers)

    def init(self):
        if self.firsttime:
            # only do this once
            print('init one time only')
            self.firsttime = False
            self.bind(focus=self.on_focus)

            self.loop = loop
            self.options = self.loop.options
            self.Dialog = ETMDialog(parent=self, options=self.options)
            self.loop.parent = self
            res = self.loop.do_command('a')
            self.start_timer()
            return(res)
        return()

    def start_timer(self):
        self.now = get_current_time()
        nxt = (60 - self.now.second)
        print(self.now)
        Clock.schedule_once(self.timer_callback, nxt)

    def timer_callback(self, dt):
        self.start_timer()

    def get_input(self, question):
        self.command_mode = False
        return(question)

    def process_input(self):
        """
        This is called whenever enter is pressed in the input field.
        Action depends upon comand_mode.
        Append input to history, process it and show the result in output.
        """
        cmd = self.text.strip()

        # if not cmd:
        #     return(True)

        if self.mode == 'command':
            if cmd == 'q':
                sys.exit()
            cmd = cmd.strip()
            if cmd[0] in ['a', 'r', 't']:
                # simple command history for report commands
                if cmd in self.history:
                    self.history.remove(cmd)
                self.history.append(cmd)
                self.index = len(self.history) - 1
            # select everything in input to make it easy to clear
            self.select_all()
            try:
                res = loop.do_command(cmd)
            except:
                return _('could not process command "{0}"').format(cmd)

        elif self.mode == 'edit':
            print('edit', cmd)
            res = loop._do_edit(cmd)

        elif self.mode == 'delete':
            print('deleted', cmd)
            loop._do_delete(cmd)
            res = ''

        elif self.mode == 'finish':
            print('finish', cmd)
            loop._do_finish(cmd)
            res = ''

        elif self.mode == 'new_date':
            print('date', cmd)
            res = loop._new_date(cmd)

        if not res:
            return(True)
        print('display and scroll to top')
        self.output_wid.text = res
        self.scroll_wid.scroll_y = 1
        self.scroll_to_top()

    def scroll_to_top(self):
        # print('scrolling')
        self.scroll_wid.update_from_scroll()

    def previous_history(self):
        """
        Replace input with the previous history item.
        """
        if self.index >= 1:
            self.index -= 1
            self.text = self.history[self.index]

    def next_history(self):
        """
        Replace input with the next history item.
        """
        if self.index + 1 < len(self.history):
            self.index += 1
            self.text = self.history[self.index]

    def on_focus(self, instance, value):
        if value:
            print('focused', instance)
        else:
            print('defocused', instance)
        super(ETMTextInput, self).on_focus(instance, value)


class BoxIOWidget(BoxLayout):
    input_wid = ObjectProperty()
    status_wid = ObjectProperty()
    output_wid = ObjectProperty()
    scroll_wid = ObjectProperty()


class etmApp(App):
    title = 'etm'
    icon = 'etmlogo_512x512x32.png'

    def build(self):
        return BoxIOWidget()

if __name__ == "__main__":
    init_localization()
    etmdir = ''
    if len(sys.argv) > 1:
        etmdir = sys.argv.pop(1)
    (user_options, options, use_locale) = data.get_options(etmdir)
    loop = data.ETMCmd(options)
    etmApp().run()
